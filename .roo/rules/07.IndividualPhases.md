# 7. Individual Phases Breakdown
This document provides a detailed, step-by-step elaboration of the four development phases outlined in the Project Roadmap.
________________________________________
Phase 1: Foundation & MVP – The Core Archive
Goal: To establish the project's technical foundation and deliver the essential functionality for importing and viewing cards.
Detailed Steps:
1.	Project Scaffolding (Monorepo Setup):
o	Create the root CardsRepo directory.
o	Initialize a pnpm workspace to manage the monorepo.
o	Create two main packages:
	packages/client: For the React frontend application.
	packages/server: For the Node.js/Express backend.
2.	Server Development (Backend API V1):
o	Initialize a new Node.js project with TypeScript in packages/server.
o	Install dependencies: express, cors, multer (for file uploads), and dev dependencies like @types/express.
o	Set up a basic Express server that listens on a configurable port and enables CORS.
o	Data Storage: Create a data directory in the server package, containing two subdirectories: cards (for JSON files) and images (for PNG avatars).
o	API Endpoints:
	POST /api/cards/upload:
	Accepts a .png file upload.
	Uses the migrated png.ts logic to extract character data and the avatar.
	Saves the character data as a new, uniquely identified .json file in data/cards/.
	Saves the avatar as a .png file in data/images/, linking it within the JSON file.
	GET /api/cards:
	Reads all .json files from the data/cards/ directory.
	Returns an array of all card data for the main gallery view.
	GET /api/cards/:id:
	Retrieves the data for a single card by reading its specific .json file.
	GET /api/images/:imageFilename:
	Serves the static image files from the data/images/ directory.
3.	Client Development (Frontend UI):
o	Initialize a new React project using Vite and TypeScript in packages/client.
o	Install dependencies: react-router-dom, zustand, tailwindcss.
o	Configure Tailwind CSS for utility-first styling.
o	Logic Migration: Adapt and migrate the core PNG parsing logic from CCEditor/src/tools/png.ts into a client-side utility module (src/lib/card-parser.ts).
o	State Management: Set up a simple global store with Zustand to handle the list of cards and UI state (e.g., loading status).
o	Component Development:
	UploadCard: A component with a file input or drag-and-drop zone to POST a card to the /api/cards/upload endpoint, with clear user feedback on success or failure.
	CardGallery: The main page. Fetches all cards from /api/cards and displays them in a responsive grid, showing each card's image and name.
	CardDetails: A read-only page to display the full details of a selected card, fetched from /api/cards/:id.
o	Routing: Implement react-router-dom to navigate between the CardGallery (/) and CardDetails (/card/:id) pages.
________________________________________
Phase 2: Core Features – Organization & Interaction
Goal: To build upon the MVP by adding the fundamental tools for organizing, editing, and filtering the card collection.
Detailed Steps:
1.	Card Management (CRUD Operations):
o	Backend:
	PUT /api/cards/:id: Create an endpoint to update a card. It will find the corresponding JSON file and overwrite it with the new data from the request body.
	DELETE /api/cards/:id: Create an endpoint to delete a card. It will remove the card's JSON file and its associated image file.
o	Frontend:
	On the CardDetails page, add an "Edit" button. This will toggle the view into an editable form, pre-filled with the card's data.
	Migrate and adapt necessary input components from CCEditor (e.g., for text arrays, long text fields) for the edit form.
	The form's "Save" button will trigger the PUT request.
	Add a "Delete" button with a confirmation dialog that triggers the DELETE request.
2.	Tagging System:
o	Backend:
	Update the card JSON model to include a tags: string[] array.
	Create a GET /api/tags endpoint that scans all card files, aggregates a list of all unique tags, and returns it.
o	Frontend:
	In the "Edit Card" form, add a tag input component (similar to CCEditor's TagPicker). It should suggest existing tags from the API and allow the creation of new ones.
	Display tags prominently on both the CardGallery and CardDetails views.
3.	Search & Filtering (V1):
o	Backend:
	Enhance the GET /api/cards endpoint to accept query parameters:
	q=<search_term>: Filters cards by checking for the term in the name, creator, and description.
	tags=<tag1,tag2>: Filters cards to return only those containing all specified tags.
o	Frontend:
	In the CardGallery, add a search bar that triggers a debounced refetch of cards using the q parameter.
	Add a multi-select filter component for tags, which refetches cards using the tags parameter.
4.	User Experience:
o	Implement a light/dark mode toggle using Tailwind's dark: variant and persist the user's choice in localStorage.
________________________________________
Phase 3: Advanced Management – Power & Efficiency
Goal: To introduce "power-user" features for managing a large collection with greater control and efficiency.
Detailed Steps:
1.	Advanced Filtering:
o	Backend: Further enhance GET /api/cards to accept more boolean/enum query parameters: hasLorebook, hasGallery, isFavorite, rating.
o	Frontend: Add a dedicated, collapsible "Filters" panel to the CardGallery with UI elements (checkboxes, star rating inputs) for these new filter options.
2.	Favorites System:
o	Backend: Add an isFavorite: boolean field to the card JSON model. The PUT endpoint will handle updating this field.
o	Frontend: Add a "Favorite" icon/button to each card in the gallery and on the details page to quickly toggle its status.
3.	Bulk Actions:
o	Frontend:
	Implement a "select mode" for the CardGallery that adds a checkbox to each card.
	When items are selected, display a contextual action bar (e.g., "Add Tags", "Delete Selected").
o	Backend:
	Create a POST /api/cards/bulk-update endpoint. It will accept an action type (add_tags, delete) and an array of cardIds to perform the operation on.
4.	Merge Cards:
o	Frontend:
	Create a dedicated "Merge" page/UI flow. The user selects two cards to compare.
	The UI will present a side-by-side view of all fields from both cards, with radio buttons allowing the user to select which data to keep for the final merged card.
o	Backend:
	Create a POST /api/cards/merge endpoint. It accepts the IDs of the two source cards and a final JSON object for the new card.
	The backend will create the new card, and then archive or delete the two source cards.
5.	Tag Management Page:
o	Frontend: A new page at /tags to manage all tags.
o	Backend:
	PUT /api/tags/:oldName: Endpoint to rename a tag across all cards.
	DELETE /api/tags/:tagName: Endpoint to remove a tag from all cards.
	POST /api/tags/merge: Endpoint to merge multiple source tags into a single target tag.
________________________________________
Phase 4: Personalization, Data Integrity & Deployment
Goal: To add final touches of personalization, ensure data longevity with backup and versioning, and implement basic security.
Detailed Steps:
1.	Data Integrity:
o	Backup & Restore (Backend):
	GET /api/admin/backup: An endpoint that creates a .zip archive of the entire data directory (cards and images) and streams it to the user.
	POST /api/admin/restore: A protected endpoint that accepts a .zip file, wipes the current data directory, and extracts the backup. This requires strong user confirmation.
o	Versioning (Backend):
	Modify the PUT /api/cards/:id logic. Before overwriting the card's JSON file, it will copy the current version into an archive/:card_id/ subfolder, naming it with a timestamp. This creates a historical record of every edit.
o	Frontend: Create a "Settings" page with buttons to trigger the backup and restore flows.
2.	Personalization:
o	User Notes: Add a userNotes: string field to the card model. Add a corresponding rich-text editor on the CardDetails page for users to add their own private notes to a card.
3.	Security (Single-User):
o	Backend:
	Use a .env file on the server to store a master password.
	Create a POST /api/auth/login endpoint that validates a password against the environment variable and returns a signed JWT.
	Create an authentication middleware to protect all other API endpoints, requiring a valid JWT in the Authorization header.
o	Frontend:
	Create a Login page. If no valid JWT is found in localStorage, redirect the user to this page.
	On successful login, store the JWT and attach it to all subsequent API requests. Add a "Logout" button to clear it.
4.	Deployment Documentation:
o	Update the root README.md with clear, step-by-step instructions for a non-developer to:
	Install dependencies (pnpm install).
	Configure the required .env file for the server.
	Run the application locally (pnpm dev).
	Access the application from other devices on the same network.